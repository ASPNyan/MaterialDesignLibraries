@using MaterialDesign.Color.Colorspaces
@using MaterialDesign.Color.Schemes
@using MaterialDesign.Theming.Web
@using System.Diagnostics.CodeAnalysis
@using MaterialDesign.Color.Extensions
@rendermode RenderMode.InteractiveAuto
@page "/Palettes"

<h1>Palettes</h1>
<h2>Original</h2>

<HCTSelector Hue="@Hue" Chroma="@Chroma" Tone="@Tone" @bind-OnHCTUpdate="@HCTUpdate" 
             UseChromaPercentage="@true" UsePreciseChromaPercentage="@true">
    <HSlider>
        <input type="range" min="0" max="359" step="0.1" value="@Hue" @oninput="@OnHueChange"/>
    </HSlider>
    <CSlider>
        <input type="range" min="0" max="100" step="0.1" value="@Chroma" @oninput="@OnChromaChange"/>
    </CSlider>
    <TSlider>
        <input type="range" min="0" max="100" step="0.1" value="@Tone" @oninput="@OnToneChange"/>
    </TSlider>
</HCTSelector>

@{
    RGBA rgba = HCTA.ToRGBA();
    <p style="background: @rgba.ToString(); color: @HCTA.ContrastTo(4.5).ToRGBA().ToString(); width: 300px;">
        @rgba.ToString()
    </p>
}

@foreach (DynamicScheme scheme in AllSchemes)
{
    <DynamicSchemePalettes Tones="@Tones" Scheme="@scheme" />
}

<style>
    .HCTSelector {
        width: 300px;
        height: 40vh;
    }
    
    .DisplayWindow {
        width: 100%;
        height: 60px;
    }
    
    .HCTSelector input {
        width: 100%;
    }
</style>

@code {
    private static readonly double[] Tones = [100, 99, 95, 90, 80, 70, 60, 50, 40, 30, 20, 10, 0];

    private HCTA HCTA => new(Hue, Chroma, Tone);
    
    private double Hue { get; set; }

    private double Chroma { get; set; }

    private double Tone { get; set; }

    [NotNull] private Func<Task>? HCTUpdate { get; set; }

    private DateTime _lastUpdate = DateTime.MinValue;
    
    private Task OnHueChange(ChangeEventArgs args)
    {
        if (!double.TryParse(args.Value as string, out double value)) 
            throw new Exception("Invalid method for onchange event.");
        if (_lastUpdate - DateTime.Now > TimeSpan.FromMilliseconds(1)) return Task.CompletedTask;
        _lastUpdate = DateTime.Now;

        Hue = value;
        return HCTUpdate();
    }
    
    private Task OnChromaChange(ChangeEventArgs args)
    {
        if (!double.TryParse(args.Value as string, out double value)) 
            throw new Exception("Invalid method for onchange event.");
        if (_lastUpdate - DateTime.Now > TimeSpan.FromMilliseconds(1)) return Task.CompletedTask;
        _lastUpdate = DateTime.Now;

        Chroma = value;
        return HCTUpdate();
    }
    
    private Task OnToneChange(ChangeEventArgs args)
    {
        if (!double.TryParse(args.Value as string, out double value)) 
            throw new Exception("Invalid method for onchange event.");
        if (_lastUpdate - DateTime.Now > TimeSpan.FromMilliseconds(1)) return Task.CompletedTask;
        _lastUpdate = DateTime.Now;

        Tone = value;
        return HCTUpdate();
    }

    private const bool IsDark = true;
    private const bool IsNotDark = false;
    
    private ContentScheme ContentScheme => new(HCTA, IsDark);
    private ContentScheme LightContentScheme => new(HCTA, IsNotDark);
    private ExpressiveScheme ExpressiveScheme => new(HCTA, IsDark);
    private ExpressiveScheme LightExpressiveScheme => new(HCTA, IsNotDark);
    private FidelityScheme FidelityScheme => new(HCTA, IsDark);
    private FidelityScheme LightFidelityScheme => new(HCTA, IsNotDark);
    private FruitSaladScheme FruitSaladScheme => new(HCTA, IsDark);
    private FruitSaladScheme LightFruitSaladScheme => new(HCTA, IsNotDark);
    private MonochromeScheme MonochromeScheme => new(HCTA, IsDark);
    private MonochromeScheme LightMonochromeScheme => new(HCTA, IsNotDark);
    private NeutralScheme NeutralScheme => new(HCTA, IsDark);
    private NeutralScheme LightNeutralScheme => new(HCTA, IsNotDark);
    private RainbowScheme RainbowScheme => new(HCTA, IsDark);
    private RainbowScheme LightRainbowScheme => new(HCTA, IsNotDark);
    private TonalSpotScheme TonalSpotScheme => new(HCTA, IsDark);
    private TonalSpotScheme LightTonalSpotScheme => new(HCTA, IsNotDark);
    private VibrantScheme VibrantScheme => new(HCTA, IsDark);
    private VibrantScheme LightVibrantScheme => new(HCTA, IsNotDark);

    private DynamicScheme[] DarkSchemes => [ContentScheme, ExpressiveScheme, FidelityScheme, 
                                                           FruitSaladScheme, MonochromeScheme, NeutralScheme,
                                                           RainbowScheme, TonalSpotScheme, VibrantScheme];
    
    private DynamicScheme[] LightSchemes => [LightContentScheme, LightExpressiveScheme, LightFidelityScheme, 
                                                            LightFruitSaladScheme, LightMonochromeScheme, LightNeutralScheme,
                                                            LightRainbowScheme, LightTonalSpotScheme, LightVibrantScheme];
    
    private IEnumerable<DynamicScheme> AllSchemes => [..DarkSchemes, ..LightSchemes];
}