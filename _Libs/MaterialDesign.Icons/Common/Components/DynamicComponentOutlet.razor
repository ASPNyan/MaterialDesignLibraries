@implements IDisposable

@_renderContent

@if (ExtraSources is not null)
{
    foreach ((Type type, IDictionary<string, object>? attributes) in ExtraSources)
    {
        <DynamicComponent Type="@type" Parameters="@attributes"/>
    }
}

@code
{
    internal static List<string> ExistingOutlets { get; } = [];
    
    [Parameter, EditorRequired]
    public virtual string? Id { get; set; }
    
    [Parameter]
    public List<(Type ComponentType, IDictionary<string, object>? Attributes)>? ExtraSources { get; set; }

    private static readonly List<(Type ComponentType, IDictionary<string, object>? Attributes)> StaticExtraSources = [];
    public static void AddComponentSource<TComponent>(IDictionary<string, object>? attributes= null) => 
        StaticExtraSources.Add((typeof(TComponent), attributes));

    private RenderFragment? _renderContent;

    protected override void OnInitialized()
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(Id);
        DynamicComponentContent.OnChangeWithId += UpdateState;
        ExistingOutlets.Add(Id);
        ExtraSources?.AddRange(StaticExtraSources);
    }

    private async void UpdateState(string id)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(Id);
        await InvokeAsync(() =>
        {
            _renderContent = builder =>
            {
                List<RenderFragment> fragments = DynamicComponentContent.GetContent(Id);
                for (int i = 0; i < fragments.Count; i++) builder.AddContent(i, fragments[i]);
            };
            
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        ArgumentException.ThrowIfNullOrEmpty(Id);
        DynamicComponentContent.OnChangeWithId -= UpdateState;
        ExistingOutlets.Remove(Id);
    }
}